---
title: Primitives
---

## Lamport Signatures

*How Lamport Signatures Work*

1.	Key Generation:
    - A private key consists of two sets of random values (bits), each of a predetermined length (e.g., 256 bits for a 128-bit hash function).
    - Each set corresponds to the possible values (0 or 1) of a bit in the message.
    - The public key is generated by hashing each of the private key values.
2.	Signing a Message:
    - The message to be signed is first hashed to create a fixed-length bit string.
    - For each bit in the hashed message, the corresponding value from the private key is used as the signature. If the bit is 0, the first set’s value is used; if the bit is 1, the second set’s value is used.
3.	Verifying a Signature:
    - The verifier hashes each value in the signature and compares it to the corresponding value in the public key. If all values match, the signature is valid.

### Example in the Context of BitVM2

Let's consider the excerpt's context where each script in BitVM2 must share state with other scripts using Lamport signatures.

#### Key Generation
1. **Private Key:**
   - Private key for a script consists of two sets of random values:
     - Set 1: $\{ sk_{0,0}, sk_{0,1}, \ldots, sk_{0,255} \} $
     - Set 2: $\{ sk_{1,0}, sk_{1,1}, \ldots, sk_{1,255} \}$ 

2. **Public Key:**
   - Public key is generated by hashing each private key value:
     - Set 1: $\{ pk_{0,0} = H(sk_{0,0}), pk_{0,1} = H(sk_{0,1}), \ldots, pk_{0,255} = H(sk_{0,255}) \}$
     - Set 2: $\{ pk_{1,0} = H(sk_{1,0}), pk_{1,1} = H(sk_{1,1}), \ldots, pk_{1,255} = H(sk_{1,255}) \}$

#### Signing a Message
- Suppose a script needs to sign the message "Transaction X from script A to script B."
- First, hash the message to get a bit string:
  - $H(\text{"Transaction X from script A to script B"}) = 101010\ldots$ (256 bits)

- Use the corresponding private key values for each bit:
  - For each bit in the hashed message, if the bit is 0, use the corresponding value from Set 1; if 1, use the value from Set 2.
  - Signature: $\{ sk_{1,0}, sk_{0,1}, sk_{1,2}, sk_{0,3}, \ldots \}$

#### Verifying a Signature
- The verifier hashes each value in the signature and compares it to the corresponding value in the public key:
  - If the bit is 0, check $H(sk_{0,i})$ against $pk_{0,i}$.
  - If the bit is 1, check $H(sk_{1,i})$ against $pk_{1,i}$.

#### BitVM2 Context
In BitVM2, each script needs to prove the integrity of its inputs and outputs to other scripts. If two scripts equivocate (i.e., provide conflicting information about their inputs and outputs), a fraud proof can be presented using the Lamport signature.

**Example:**
- Script A and Script B are part of a larger transaction process.
- Script A produces an output $O_A$ and signs it using its Lamport signature.
- Script B consumes $O_A$ as its input and produces an output $O_B$, also signing it with its Lamport signature.

If Script A claims $O_A = X$ in one instance and $O_A = Y$ in another, anyone can produce a fraud proof by showing the conflicting signatures. Since each signature uniquely ties to a specific message (input/output), any inconsistency can be detected by comparing the signatures.

### Summary
Lamport signatures provide a secure method to sign messages, ensuring the integrity of inputs and outputs in BitVM2 scripts. If scripts equivocate about their state, the fraudulent behavior can be detected through the comparison of their Lamport signatures.